<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Device Detail - OTA Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        /* ===============================
           General layout
        ================================ */
        .section-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #111827;
        }

        .loading {
            color: #6b7280;
            font-style: italic;
        }

        /* ===============================
           OTA Banner
        ================================ */
        .ota-banner {
            border: 1px solid #e5e7eb;
            padding: 12px;
            margin-bottom: 16px;
            background: #f9fafb;
        }

        .ota-banner.allow {
            border-left: 4px solid #15803d;
        }

        .ota-banner.delay {
            border-left: 4px solid #92400e;
        }

        .ota-banner.block {
            border-left: 4px solid #b91c1c;
        }

        .ota-banner.retry {
            border-left: 4px solid #1d4ed8;
        }

        .ota-banner .action {
            font-weight: 700;
            letter-spacing: 0.05em;
            color: #111827;
        }

        .ota-banner .confidence {
            color: #374151;
            margin-top: 4px;
            font-size: 14px;
        }

        .ota-banner .section {
            margin-top: 8px;
            font-size: 14px;
        }

        .ota-banner .section b {
            display: block;
            margin-bottom: 4px;
            color: #111827;
        }

        .ota-banner .section ul {
            margin: 4px 0 0 16px;
            padding: 0;
            list-style: disc;
        }

        .ota-banner .section ul li {
            color: #4b5563;
            margin-bottom: 2px;
        }

        /* ===============================
           Anomaly Event
        ================================ */
        .anomaly-event {
            border-top: 1px solid #e5e7eb;
            padding: 14px 0;
        }

        .anomaly-event:first-child {
            border-top: none;
        }

        .timestamp {
            color: #6b7280;
            font-size: 12px;
            margin-bottom: 6px;
        }

        .headline {
            font-weight: 600;
            margin-bottom: 6px;
            color: #111827;
            font-size: 15px;
        }

        .meta {
            margin-bottom: 8px;
            font-size: 14px;
            color: #374151;
        }

        .meta div {
            margin-bottom: 2px;
        }

        /* ===============================
           Severity colors (text only)
        ================================ */
        .severity-high {
            color: #b91c1c;
            font-weight: 600;
        }

        .severity-medium {
            color: #92400e;
            font-weight: 600;
        }

        .severity-low {
            color: #374151;
            font-weight: 600;
        }

        /* ===============================
           Sections
        ================================ */
        .section {
            margin-top: 8px;
            font-size: 14px;
        }

        .section b {
            display: block;
            margin-bottom: 2px;
            color: #111827;
        }

        .section ul {
            margin: 4px 0 0 16px;
            padding: 0;
            list-style: none;
        }

        .section ul li {
            font-size: 13px;
            color: #4b5563;
            margin-bottom: 2px;
        }

        /* ===============================
           OTA Recommendation Banner (Overview Tab)
        ================================ */
        .ota-recommendation-banner {
            border: 1px solid #e5e7eb;
            padding: 12px;
            margin-bottom: 16px;
            background: #f9fafb;
            font-size: 14px;
            line-height: 1.5;
        }

        .ota-recommendation-banner.allow {
            border-left: 4px solid #15803d;
        }

        .ota-recommendation-banner.delay {
            border-left: 4px solid #92400e;
        }

        .ota-recommendation-banner.block {
            border-left: 4px solid #b91c1c;
        }

        .ota-recommendation-banner.retry {
            border-left: 4px solid #1d4ed8;
        }

        .ota-recommendation-banner .action {
            font-weight: 700;
            letter-spacing: 0.05em;
            color: #111827;
            margin-bottom: 4px;
        }

        .ota-recommendation-banner .confidence {
            color: #374151;
            margin-bottom: 8px;
        }

        .ota-recommendation-banner .reason-section {
            margin-top: 8px;
        }

        .ota-recommendation-banner .reason-section b {
            display: block;
            margin-bottom: 4px;
            color: #111827;
        }

        .ota-recommendation-banner .reason-section ul {
            margin-top: 4px;
            margin-left: 16px;
            padding: 0;
            list-style: disc;
        }

        .ota-recommendation-banner .reason-section ul li {
            color: #4b5563;
            margin-bottom: 2px;
            font-family: inherit;
        }

        .ota-recommendation-banner .footer {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #e5e7eb;
            font-size: 12px;
            color: #6b7280;
        }

        .ota-recommendation-banner .footer a {
            color: #2563eb;
            text-decoration: underline;
        }

        .ota-recommendation-banner .footer a:hover {
            color: #1d4ed8;
        }
    </style>
</head>
<body class="bg-white text-gray-900">
    <!-- Sidebar -->
    <aside class="fixed left-0 top-0 h-screen w-60 bg-white border-r border-gray-200 z-50">
        <div class="p-6">
            <h1 class="text-xl font-bold text-gray-900 mb-8">OTA Dashboard</h1>
            <nav class="space-y-2">
                <a href="/" class="block px-4 py-2 rounded-lg text-gray-700 hover:bg-gray-50">Dashboard</a>
                <a href="/devices.html" class="block px-4 py-2 rounded-lg bg-blue-50 text-blue-600 font-semibold">Devices</a>
                <a href="/firmware.html" class="block px-4 py-2 rounded-lg text-gray-700 hover:bg-gray-50">Firmware</a>
                <a href="/model.html" class="block px-4 py-2 rounded-lg text-gray-700 hover:bg-gray-50">Model</a>
                <a href="/logs.html" class="block px-4 py-2 rounded-lg text-gray-700 hover:bg-gray-50">Logs</a>
                <a href="/metrics.html" class="block px-4 py-2 rounded-lg text-gray-700 hover:bg-gray-50">Metrics</a>
                <a href="/anomaly.html" class="block px-4 py-2 rounded-lg text-gray-700 hover:bg-gray-50">Anomaly</a>
            </nav>
        </div>
    </aside>

    <!-- Main Content -->
    <div class="ml-60 p-6">
        <div id="deviceInfo" class="mb-6">
            <div class="flex items-center justify-center p-8">
                <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
            </div>
        </div>

        <div class="border-b border-gray-200 mb-6 overflow-x-auto">
            <nav class="flex space-x-8 min-w-max">
                <button onclick="showTab('info')" id="tab-info" class="tab-button py-4 px-1 border-b-2 border-blue-500 font-medium text-sm text-gray-900 whitespace-nowrap">Info</button>
                <button onclick="showTab('metrics')" id="tab-metrics" class="tab-button py-4 px-1 border-b-2 border-transparent text-gray-600 hover:text-gray-900 text-sm whitespace-nowrap">Metrics</button>
                <button onclick="showTab('logs')" id="tab-logs" class="tab-button py-4 px-1 border-b-2 border-transparent text-gray-600 hover:text-gray-900 text-sm whitespace-nowrap">Logs</button>
                <button onclick="showTab('ota')" id="tab-ota" class="tab-button py-4 px-1 border-b-2 border-transparent text-gray-600 hover:text-gray-900 text-sm whitespace-nowrap">OTA History</button>
                <button onclick="showTab('anomaly')" id="tab-anomaly" class="tab-button py-4 px-1 border-b-2 border-transparent text-gray-600 hover:text-gray-900 text-sm whitespace-nowrap">Anomaly Timeline</button>
            </nav>
        </div>

        <div id="tab-content">
            <div id="content-info" class="tab-content">
                <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
                    <div id="infoContent">Loading...</div>
                </div>
            </div>

            <div id="content-metrics" class="tab-content hidden">
                <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
                    <div id="metricsContent">
                        <div class="flex items-center justify-center p-8">
                            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="content-logs" class="tab-content hidden">
                <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
                    <div id="logsContent">Loading...</div>
                </div>
            </div>

            <div id="content-ota" class="tab-content hidden">
                <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
                    <div id="otaContent">Loading...</div>
                </div>
            </div>

            <div id="content-anomaly" class="tab-content hidden">
                <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
                    <!-- CRITICAL: This tab shows HISTORY ONLY, not current state -->
                    <!-- Current anomaly state is displayed in Overview/Info tab from devices collection -->
                    <h2 class="section-title">Anomaly Timeline</h2>

                    <!-- OTA Recommendation Banner -->
                    <!-- CRITICAL: Banner visibility depends on CURRENT device state, but content comes from latest event -->
                    <div id="ota-banner" class="ota-banner hidden"></div>

                    <!-- Anomaly Events Container -->
                    <!-- CRITICAL: These are HISTORICAL events - scores shown are from when events were created -->
                    <div id="anomaly-timeline">
                        <div class="loading">Loading anomaly events...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { api } from './js/api.js';
        import { realtime } from './js/realtime.js';
        import { charts } from './js/charts.js';
        import { ui } from './js/ui.js';

        const urlParams = new URLSearchParams(window.location.search);
        const deviceId = urlParams.get('device_id');

        if (!deviceId) {
            window.location.href = '/devices.html';
        }

        let currentTab = 'info';
        let metricsCharts = {
            cpu: null,
            temperature: null,
            battery: null,
        };
        let metricsAutoRefreshInterval = null;
        let logsList = [];
        const MAX_LOGS_DISPLAY = 200;

        window.showTab = function(tab) {
            currentTab = tab;

            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('border-blue-500', 'font-medium', 'text-gray-900');
                btn.classList.add('border-transparent', 'text-gray-600');
            });
            const tabButton = document.getElementById(`tab-${tab}`);
            if (tabButton) {
                tabButton.classList.add('border-blue-500', 'font-medium', 'text-gray-900');
                tabButton.classList.remove('text-gray-600');
            }

            // Show/hide content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.add('hidden');
            });
            const contentDiv = document.getElementById(`content-${tab}`);
            if (contentDiv) {
                contentDiv.classList.remove('hidden');
            }

            // Load tab data
            loadTabData(tab);

            // Clear auto-refresh when switching away from metrics tab
            if (tab !== 'metrics' && metricsAutoRefreshInterval) {
                clearInterval(metricsAutoRefreshInterval);
                metricsAutoRefreshInterval = null;
                const checkbox = document.getElementById('metricsAutoRefresh');
                if (checkbox) checkbox.checked = false;
            }
        };

        async function loadDeviceInfo() {
            try {
                const data = await api.devices.get(deviceId);
                const device = data.data;

                // IMPORTANT: Anomaly tab is always visible (it shows history, not current state)
                // Do NOT hide tab based on isAnomaly

                document.getElementById('deviceInfo').innerHTML = `
                    <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
                        <h2 class="text-xl font-bold mb-4 text-gray-900">${device.deviceId || device.id}</h2>
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                            <div>
                                <div class="text-sm text-gray-600">Type</div>
                                <div class="font-medium text-gray-900">${device.deviceType || 'N/A'}</div>
                            </div>
                            <div>
                                <div class="text-sm text-gray-600">Status</div>
                                <div><span class="px-2 py-1 rounded-md text-xs font-medium ${ui.getStatusColor(device.status)}">${device.status || 'unknown'}</span></div>
                            </div>
                            <div>
                                <div class="text-sm text-gray-600">Firmware</div>
                                <div class="font-medium text-gray-900">${device.firmwareVersion || 'N/A'}</div>
                            </div>
                            <div>
                                <div class="text-sm text-gray-600">OTA Status</div>
                                <div><span class="px-2 py-1 rounded-md text-xs font-medium ${ui.getOTAStatusColor(device.otaStatus)}">${device.otaStatus || 'idle'}</span></div>
                            </div>
                            <div>
                                <div class="text-sm text-gray-600">Reported FW</div>
                                <div class="font-medium text-gray-900">${device.reportedFirmwareVersion || 'N/A'}</div>
                            </div>
                            <div>
                                <div class="text-sm text-gray-600">Anomaly Status</div>
                                <div>
                                    ${(() => {
                                        // STRICT: Only show anomaly badge when isAnomaly === true
                                        // Do NOT infer from anomalyScore or history
                                        if (device.isAnomaly === true) {
                                            return `<span class="px-2 py-1 rounded-md text-xs font-medium bg-red-100 text-red-800">Anomaly</span>`;
                                        } else if (device.isAnomaly === false) {
                                            return `<span class="px-2 py-1 rounded-md text-xs font-medium bg-green-100 text-green-800">Normal</span>`;
                                        } else {
                                            return '<span class="px-2 py-1 rounded-md text-xs font-medium bg-gray-100 text-gray-800">N/A</span>';
                                        }
                                    })()}
                                </div>
                            </div>
                            <div>
                                <div class="text-sm text-gray-600">Last Seen</div>
                                <div class="font-medium text-gray-900">${ui.formatDate(device.lastSeenAt || device.lastCheckin || device.lastSeen)}</div>
                            </div>
                        </div>
                    </div>
                `;

                if (currentTab === 'info') {
                    loadInfoTab(device);
                }
            } catch (error) {
                document.getElementById('deviceInfo').innerHTML =
                    `<div class="p-4 bg-red-50 border border-red-200 rounded text-red-700">Error: ${error.message}</div>`;
            }
        }

        // Load and render OTA Recommendation Banner (Overview tab)
        async function loadOTARecommendationBanner() {
            const banner = document.getElementById('otaRecommendationBanner');
            if (!banner) return;

            try {
                // STRICT: Get device to check isAnomaly (single source of truth)
                const deviceData = await api.devices.get(deviceId);
                const device = deviceData.data;

                // HARD RULE: Show banner ONLY if device.isAnomaly === true
                if (device.isAnomaly !== true) {
                    banner.classList.add('hidden');
                    return;
                }

                const data = await api.devices.anomalies(deviceId, { limit: 1 });
                const events = Array.isArray(data.data) ? data.data : [];

                if (!events.length || !events[0].otaRecommendation) {
                    banner.classList.add('hidden');
                    return;
                }

                const latest = events[0];
                const recommendation = latest.otaRecommendation;
                const action = (recommendation.action || 'allow').toUpperCase();
                const confidence = typeof recommendation.confidence === 'number'
                    ? Math.round(recommendation.confidence * 100)
                    : 0;
                const reasons = recommendation.reason || [];
                const timestamp = formatTime(latest.timestamp);

                banner.className = `ota-recommendation-banner ${recommendation.action || 'allow'}`;
                banner.innerHTML = `
                    <div class="action">OTA Recommendation (Decision Support): ${action}</div>
                    <div class="confidence">Confidence: ${confidence}%</div>
                    ${reasons.length > 0 ? `
                    <div class="reason-section">
                        <b>Reason:</b>
                        <ul>
                            ${reasons.map(r => `<li>${r}</li>`).join('')}
                        </ul>
                    </div>
                    ` : ''}
                    <div class="footer">
                        Last evaluated: ${timestamp}
                        <a href="#" onclick="showTab('anomaly'); return false;">View details ‚Üí Anomaly Timeline</a>
                    </div>
                `;
                banner.classList.remove('hidden');
            } catch (err) {
                banner.classList.add('hidden');
                console.warn('Failed to load OTA recommendation:', err);
            }
        }

        async function loadInfoTab(device) {
            document.getElementById('infoContent').innerHTML = `
                <div class="space-y-4">
                    <!-- OTA Recommendation Banner -->
                    <div id="otaRecommendationBanner" class="ota-recommendation-banner hidden"></div>

                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <div class="text-sm text-gray-600">Device ID</div>
                            <div class="font-medium text-gray-900">${device.deviceId || device.id}</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-600">Device Type</div>
                            <div class="font-medium text-gray-900">${device.deviceType || 'N/A'}</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-600">Firmware Version</div>
                            <div class="font-medium text-gray-900">${device.firmwareVersion || 'N/A'}</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-600">Reported FW Version</div>
                            <div class="font-medium text-gray-900">${device.reportedFirmwareVersion || 'N/A'}</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-600">Status</div>
                            <div><span class="px-2 py-1 rounded-md text-xs font-medium ${ui.getStatusColor(device.status)}">${device.status || 'unknown'}</span></div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-600">OTA Status</div>
                            <div><span class="px-2 py-1 rounded-md text-xs font-medium ${ui.getOTAStatusColor(device.otaStatus)}">${device.otaStatus || 'idle'}</span></div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-600">Last Seen</div>
                            <div class="font-medium text-gray-900">${ui.formatDate(device.lastSeenAt || device.lastCheckin || device.lastSeen)}</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-600">Log Count</div>
                            <div class="font-medium text-gray-900">${device.logCount || 0}</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-600">Metric Count</div>
                            <div class="font-medium text-gray-900">${device.metricCount || 0}</div>
                        </div>
                    </div>
                    <div class="mt-6 pt-6 border-t border-gray-200">
                        <h3 class="text-sm font-semibold text-gray-900 mb-3">Anomaly Status</h3>
                        <div class="space-y-2">
                            <div class="flex items-center space-x-3">
                                ${(() => {
                                    // STRICT: Only show anomaly badge when isAnomaly === true
                                    // Do NOT infer from anomalyScore or history
                                    if (device.isAnomaly === true) {
                                        return `<span class="px-3 py-1 rounded-md text-sm font-medium bg-red-100 text-red-800">Anomaly</span>`;
                                    } else if (device.isAnomaly === false) {
                                        return `<span class="px-3 py-1 rounded-md text-sm font-medium bg-green-100 text-green-800">Normal</span>`;
                                    } else {
                                        return '<span class="px-3 py-1 rounded-md text-sm font-medium bg-gray-100 text-gray-800">N/A</span>';
                                    }
                                })()}
                                ${device.anomalyScore !== null && device.anomalyScore !== undefined && typeof device.anomalyScore === 'number'
                                    ? `<span class="text-sm text-gray-600">Score: ${device.anomalyScore.toFixed(3)}</span>`
                                    : ''}
                            </div>
                            <p class="text-xs text-gray-500 mt-2">
                                Anomaly score is generated by the inference model based on recent metrics.
                            </p>
                        </div>
                    </div>
                </div>
            `;

            // Load OTA recommendation banner after rendering info tab
            await loadOTARecommendationBanner();
        }

        async function loadTabData(tab) {
            if (tab === 'info') {
                const data = await api.devices.get(deviceId);
                loadInfoTab(data.data);
            } else if (tab === 'metrics') {
                await loadMetrics();
            } else if (tab === 'logs') {
                await loadLogs();
            } else if (tab === 'ota') {
                await loadOTAHistory();
            } else if (tab === 'anomaly') {
                // CRITICAL: Loading anomaly tab does NOT update device header/overview
                // It only loads and displays historical events
                await loadAnomaly();
            }
        }

        async function loadMetrics() {
            const metricsContent = document.getElementById('metricsContent');

            // Show loading state
            metricsContent.innerHTML = `
                <div class="flex items-center justify-center p-8">
                    <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
                </div>
            `;

            try {
                const data = await api.metrics.list({ deviceId, limit: 200 });

                // Defensive: NEVER assume data exists, NEVER call .map() on undefined
                // Rules: Empty data is VALID, UI must stay on Metrics tab, no navigation reset
                const metrics = data?.data ?? [];

                if (!Array.isArray(metrics) || metrics.length === 0) {
                    metricsContent.innerHTML =
                        '<div class="p-8 text-center text-gray-500">No metrics data available</div>';
                    return;
                }

                // NOTE: Metric keys are fixed for current device models.
                // Backend supports arbitrary metrics fields.
                // UI is intentionally constrained for clarity and stability.
                // Dynamic metric rendering can be added in future iterations.

                // Transform API response to chart-friendly format
                const chartData = {
                    cpu: [],
                    temperature: [],
                    battery: [],
                };

                // Defensive: Ensure metrics is array before forEach
                (Array.isArray(metrics) ? metrics : []).forEach(metric => {
                    if (!metric || !metric.timestamp) return; // Skip invalid metrics
                    const timestamp = new Date(metric.timestamp);
                    const metricValues = metric.metrics || {};

                    // Map metric keys to chart datasets (fixed keys: cpu_usage, temperature, battery_level)
                    if (metricValues.cpu_usage !== undefined) {
                        chartData.cpu.push({ x: timestamp, y: metricValues.cpu_usage });
                    }
                    if (metricValues.temperature !== undefined) {
                        chartData.temperature.push({ x: timestamp, y: metricValues.temperature });
                    }
                    if (metricValues.battery_level !== undefined) {
                        chartData.battery.push({ x: timestamp, y: metricValues.battery_level });
                    }
                });

                // Sort all datasets by timestamp (ascending)
                Object.keys(chartData).forEach(key => {
                    chartData[key].sort((a, b) => a.x - b.x);
                });

                // Get last values for display
                const lastCpu = chartData.cpu.at(-1)?.y;
                const lastTemp = chartData.temperature.at(-1)?.y;
                const lastBattery = chartData.battery.at(-1)?.y;

                // Render charts HTML with auto-refresh toggle
                metricsContent.innerHTML = `
                    <div class="space-y-6">
                        <div class="flex items-center justify-between mb-4">
                            <div></div>
                            <label class="flex items-center space-x-2 cursor-pointer">
                                <input type="checkbox" id="metricsAutoRefresh" class="w-4 h-4 text-blue-600 rounded focus:ring-blue-500">
                                <span class="text-sm text-gray-700">Auto refresh (30s)</span>
                            </label>
                        </div>
                        <div>
                            <h3 class="text-lg font-semibold text-gray-900 mb-2">
                                CPU Usage${lastCpu !== undefined ? ` (last: ${(lastCpu * 100).toFixed(1)}%)` : ''}
                            </h3>
                            <div class="h-64">
                                <canvas id="cpuChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <h3 class="text-lg font-semibold text-gray-900 mb-2">
                                Temperature${lastTemp !== undefined ? ` (last: ${lastTemp.toFixed(1)}¬∞C)` : ''}
                            </h3>
                            <div class="h-64">
                                <canvas id="temperatureChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <h3 class="text-lg font-semibold text-gray-900 mb-2">
                                Battery Level${lastBattery !== undefined ? ` (last: ${(lastBattery * 100).toFixed(1)}%)` : ''}
                            </h3>
                            <div class="h-64">
                                <canvas id="batteryChart"></canvas>
                            </div>
                        </div>
                    </div>
                `;

                // Setup auto-refresh toggle
                const autoRefreshCheckbox = document.getElementById('metricsAutoRefresh');
                autoRefreshCheckbox.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        metricsAutoRefreshInterval = setInterval(() => {
                            if (currentTab === 'metrics') {
                                loadMetrics();
                            }
                        }, 30000);
                    } else {
                        if (metricsAutoRefreshInterval) {
                            clearInterval(metricsAutoRefreshInterval);
                            metricsAutoRefreshInterval = null;
                        }
                    }
                });

                // Destroy existing charts
                if (metricsCharts.cpu) charts.destroy('cpuChart');
                if (metricsCharts.temperature) charts.destroy('temperatureChart');
                if (metricsCharts.battery) charts.destroy('batteryChart');

                // Create CPU Usage chart
                if (chartData.cpu.length > 0) {
                    metricsCharts.cpu = charts.create('cpuChart', {
                        type: 'line',
                        data: {
                            datasets: [{
                                label: 'CPU Usage',
                                data: chartData.cpu,
                                borderColor: 'rgb(59, 130, 246)',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                tension: 0.1,
                                borderWidth: 2,
                                fill: true,
                            }],
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                mode: 'index',
                                intersect: false,
                            },
                            plugins: {
                                tooltip: {
                                    enabled: true,
                                    callbacks: {
                                        title: (items) => {
                                            return new Date(items[0].parsed.x).toLocaleString();
                                        },
                                        label: (context) => {
                                            return `CPU Usage: ${(context.parsed.y * 100).toFixed(1)}%`;
                                        },
                                    },
                                },
                                legend: {
                                    display: false,
                                },
                            },
                            scales: {
                                x: {
                                    type: 'time',
                                    time: {
                                        tooltipFormat: 'yyyy-MM-dd HH:mm:ss',
                                        displayFormats: {
                                            second: 'HH:mm:ss',
                                            minute: 'HH:mm',
                                            hour: 'HH:mm',
                                        },
                                    },
                                    ticks: {
                                        color: '#6b7280',
                                    },
                                    grid: {
                                        color: '#e5e7eb',
                                    },
                                },
                                y: {
                                    ticks: {
                                        color: '#6b7280',
                                        callback: function(value) {
                                            return (value * 100).toFixed(0) + '%';
                                        },
                                    },
                                    grid: { color: '#e5e7eb' },
                                    min: 0,
                                    max: 1,
                                },
                            },
                        },
                    });
                } else {
                    document.getElementById('cpuChart').parentElement.innerHTML =
                        '<div class="p-4 text-center text-gray-500">No CPU usage data available</div>';
                }

                // Create Temperature chart
                if (chartData.temperature.length > 0) {
                    metricsCharts.temperature = charts.create('temperatureChart', {
                        type: 'line',
                        data: {
                            datasets: [{
                                label: 'Temperature',
                                data: chartData.temperature,
                                borderColor: 'rgb(239, 68, 68)',
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                tension: 0.1,
                                borderWidth: 2,
                                fill: true,
                            }],
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                mode: 'index',
                                intersect: false,
                            },
                            plugins: {
                                tooltip: {
                                    enabled: true,
                                    callbacks: {
                                        title: (items) => {
                                            return new Date(items[0].parsed.x).toLocaleString();
                                        },
                                        label: (context) => {
                                            return `Temperature: ${context.parsed.y.toFixed(1)}¬∞C`;
                                        },
                                    },
                                },
                                legend: {
                                    display: false,
                                },
                            },
                            scales: {
                                x: {
                                    type: 'time',
                                    time: {
                                        tooltipFormat: 'yyyy-MM-dd HH:mm:ss',
                                        displayFormats: {
                                            second: 'HH:mm:ss',
                                            minute: 'HH:mm',
                                            hour: 'HH:mm',
                                        },
                                    },
                                    ticks: {
                                        color: '#6b7280',
                                    },
                                    grid: {
                                        color: '#e5e7eb',
                                    },
                                },
                                y: {
                                    ticks: {
                                        color: '#6b7280',
                                        callback: function(value) {
                                            return value.toFixed(1) + '¬∞C';
                                        },
                                    },
                                    grid: { color: '#e5e7eb' },
                                },
                            },
                        },
                    });
                } else {
                    document.getElementById('temperatureChart').parentElement.innerHTML =
                        '<div class="p-4 text-center text-gray-500">No temperature data available</div>';
                }

                // Create Battery Level chart
                if (chartData.battery.length > 0) {
                    metricsCharts.battery = charts.create('batteryChart', {
                        type: 'line',
                        data: {
                            datasets: [{
                                label: 'Battery Level',
                                data: chartData.battery,
                                borderColor: 'rgb(34, 197, 94)',
                                backgroundColor: 'rgba(34, 197, 94, 0.1)',
                                tension: 0.1,
                                borderWidth: 2,
                                fill: true,
                            }],
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                mode: 'index',
                                intersect: false,
                            },
                            plugins: {
                                tooltip: {
                                    enabled: true,
                                    callbacks: {
                                        title: (items) => {
                                            return new Date(items[0].parsed.x).toLocaleString();
                                        },
                                        label: (context) => {
                                            return `Battery Level: ${(context.parsed.y * 100).toFixed(1)}%`;
                                        },
                                    },
                                },
                                legend: {
                                    display: false,
                                },
                            },
                            scales: {
                                x: {
                                    type: 'time',
                                    time: {
                                        tooltipFormat: 'yyyy-MM-dd HH:mm:ss',
                                        displayFormats: {
                                            second: 'HH:mm:ss',
                                            minute: 'HH:mm',
                                            hour: 'HH:mm',
                                        },
                                    },
                                    ticks: {
                                        color: '#6b7280',
                                    },
                                    grid: {
                                        color: '#e5e7eb',
                                    },
                                },
                                y: {
                                    ticks: {
                                        color: '#6b7280',
                                        callback: function(value) {
                                            return (value * 100).toFixed(0) + '%';
                                        },
                                    },
                                    grid: { color: '#e5e7eb' },
                                    min: 0,
                                    max: 1,
                                },
                            },
                        },
                    });
                } else {
                    document.getElementById('batteryChart').parentElement.innerHTML =
                        '<div class="p-4 text-center text-gray-500">No battery level data available</div>';
                }
            } catch (error) {
                metricsContent.innerHTML =
                    `<div class="p-4 bg-red-50 border border-red-200 rounded text-red-700">Error: ${error.message}</div>`;
            }
        }

        function renderLogs(logs) {
            const logsContent = document.getElementById('logsContent');

            // Defensive: Empty data is VALID, show empty state, stay on tab
            if (!Array.isArray(logs) || logs.length === 0) {
                logsContent.innerHTML = `
                    <div class="space-y-4">
                        <div class="p-8 text-center text-gray-500">No logs available for this device</div>
                        <div class="text-center">
                            <a href="/logs.html?deviceId=${encodeURIComponent(deviceId)}"
                               class="text-blue-600 hover:text-blue-700 underline">
                                View all logs in Logs tab ‚Üí
                            </a>
                        </div>
                    </div>
                `;
                return;
            }

            // Backend already sorts by @timestamp DESC, so no frontend sorting needed
            // Logs are already normalized with timestamp field

            logsContent.innerHTML = `
                <div class="space-y-4">
                    <div class="flex justify-between items-center">
                        <h3 class="text-lg font-semibold text-gray-900">Recent Logs (Latest 10)</h3>
                        <a href="/logs.html?deviceId=${encodeURIComponent(deviceId)}"
                           class="text-sm text-blue-600 hover:text-blue-700 underline">
                            View all logs ‚Üí
                        </a>
                    </div>
                    <div class="space-y-2">
                        ${logs.map(log => {
                            const timestamp = log.timestamp ? ui.formatDate(log.timestamp) : 'unknown time';
                            const levelColor = log.level === 'ERROR'
                                ? 'bg-red-100 text-red-800'
                                : log.level === 'WARN'
                                ? 'bg-yellow-100 text-yellow-800'
                                : 'bg-blue-100 text-blue-800';

                            return `
                                <div class="p-3 bg-gray-50 rounded text-sm border border-gray-200">
                                    <div class="flex justify-between">
                                        <span class="text-gray-600">${timestamp}</span>
                                        <span class="px-2 py-1 rounded text-xs ${levelColor}">${log.level.toUpperCase()}</span>
                                    </div>
                                    <div class="mt-1 text-gray-900">${log.message}</div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            `;
        }

        async function loadLogs() {
            const logsContent = document.getElementById('logsContent');

            // Show loading state
            logsContent.innerHTML = `
                <div class="flex items-center justify-center p-8">
                    <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
                </div>
            `;

            try {
                // Call API /api/logs with deviceId and limit 10 (latest logs only)
                const response = await api.logs.list({ deviceId, limit: 10 });

                // Defensive: read from data.data (backend returns { success: true, data: [...] })
                if (!response || !response.data) {
                    logsContent.innerHTML =
                        '<div class="p-8 text-center text-gray-500">No logs available for this device</div>';
                    logsList = [];
                    return;
                }

                const rawLogs = Array.isArray(response.data) ? response.data : [];

                // Normalize logs: map @timestamp to timestamp for clean UI rendering
                const normalizedLogs = rawLogs.map(log => ({
                    id: log.id,
                    timestamp: log['@timestamp'] || log.timestamp,
                    deviceId: log.deviceId || log.device_id || 'N/A',
                    level: log.level || 'info',
                    message: log.message || '(empty message)',
                }));

                logsList = normalizedLogs;
                renderLogs(logsList);
            } catch (error) {
                // Show error state
                logsContent.innerHTML =
                    `<div class="p-4 bg-red-50 border border-red-200 rounded text-red-700">Error: ${error.message || 'Failed to load logs'}</div>`;
                logsList = [];
            }
        }

        function prependLog(newLog) {
            // NOTE: For MVP, realtime logs are prepended locally.
            // Future improvement: virtualized list or server-side pagination.

            if (!newLog) return;

            // Normalize log: map @timestamp to timestamp
            const log = {
                id: newLog.id || `realtime-${Date.now()}`,
                deviceId: newLog.deviceId || newLog.device_id || 'unknown',
                level: newLog.level || 'info',
                message: newLog.message || '(empty message)',
                timestamp: newLog['@timestamp'] || newLog.timestamp || new Date().toISOString(),
            };

            // Prepend to list (newest first)
            logsList.unshift(log);

            // Cap list length to 10 (latest only)
            if (logsList.length > 10) {
                logsList = logsList.slice(0, 10);
            }

            // Re-render if on logs tab
            if (currentTab === 'logs') {
                renderLogs(logsList);
            }
        }

        async function loadOTAHistory() {
            const otaContent = document.getElementById('otaContent');
            
            if (!otaContent) {
                console.error('OTA content element not found');
                return;
            }
            
            // Show loading state
            otaContent.innerHTML = `
                <div class="flex items-center justify-center p-8">
                    <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
                </div>
            `;

            try {
                const data = await api.devices.otaEvents(deviceId);
                const events = data.data || [];

                // Action ‚Üí UI mapping (exact as specified)
                const actionMapping = {
                    'assign': { icon: 'üìù', label: 'Firmware assigned', color: 'blue' },
                    'download': { icon: '‚¨áÔ∏è', label: 'Downloading firmware', color: 'cyan' },
                    'update': { icon: 'üîÑ', label: 'Updating firmware', color: 'orange' },
                    'success': { icon: '‚úÖ', label: 'Update successful', color: 'green' },
                    'fail': { icon: '‚ùå', label: 'Update failed', color: 'red' },
                };

                // Color classes for Tailwind
                const colorClasses = {
                    'blue': 'border-blue-500 bg-blue-50',
                    'cyan': 'border-cyan-500 bg-cyan-50',
                    'orange': 'border-orange-500 bg-orange-50',
                    'green': 'border-green-500 bg-green-50',
                    'red': 'border-red-500 bg-red-50',
                };

                if (events.length === 0) {
                    otaContent.innerHTML = `
                        <div class="text-center py-12 text-gray-500">
                            No OTA activity recorded for this device.
                        </div>
                    `;
                    return;
                }

                // Events are already sorted by createdAt ASC from backend
                otaContent.innerHTML = `
                    <div class="relative">
                        <div class="absolute left-6 top-0 bottom-0 w-0.5 bg-gray-200"></div>
                        <div class="space-y-6">
                            ${events.map((event, index) => {
                                const mapping = actionMapping[event.action] || { icon: '‚Ä¢', label: event.action, color: 'gray' };
                                const colorClass = colorClasses[mapping.color] || 'border-gray-500 bg-gray-50';
                                const timestamp = new Date(event.createdAt).toLocaleString();
                                
                                return `
                                    <div class="relative flex items-start">
                                        <div class="flex-shrink-0 w-12 h-12 rounded-full ${colorClass} border-2 flex items-center justify-center text-xl z-10">
                                            ${mapping.icon}
                                        </div>
                                        <div class="ml-4 flex-1 min-w-0">
                                            <div class="flex items-center justify-between">
                                                <h3 class="text-base font-medium text-gray-900">${mapping.label}</h3>
                                                <span class="text-sm text-gray-500">${timestamp}</span>
                                            </div>
                                            <div class="mt-1 text-sm text-gray-600">
                                                Firmware version: <span class="font-mono font-medium">${event.firmwareVersion}</span>
                                            </div>
                                            ${event.source ? `
                                                <div class="mt-1 text-xs text-gray-500">
                                                    Source: ${event.source}
                                                </div>
                                            ` : ''}
                                            ${event.action === 'fail' && event.reason ? `
                                                <div class="mt-2 p-2 bg-red-50 border border-red-200 rounded text-sm text-red-700">
                                                    ${event.reason}
                                                </div>
                                            ` : ''}
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            } catch (error) {
                const errorContent = document.getElementById('otaContent');
                if (!errorContent) {
                    console.error('OTA content element not found in error handler');
                    return;
                }
                
                if (error.message && (error.message.includes('404') || error.message.includes('not found'))) {
                    errorContent.innerHTML = `
                        <div class="p-4 bg-red-50 border border-red-200 rounded text-red-700">
                            Device not found.
                        </div>
                    `;
                } else {
                    errorContent.innerHTML = `
                        <div class="p-4 bg-red-50 border border-red-200 rounded text-red-700">
                            Failed to load OTA history.
                        </div>
                    `;
                }
            }
        }

        // Format timestamp
        function formatTime(ts) {
            if (!ts) return '';
            const d = new Date(ts);
            return d.toLocaleString('en-US', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
        }

        // Engineering Report Style - Render OTA Banner
        function renderOTABanner(recommendation, banner) {
            if (!recommendation || !recommendation.action) {
                banner.classList.add('hidden');
                return;
            }

            const action = recommendation.action.toUpperCase();
            const confidence = typeof recommendation.confidence === 'number'
                ? Math.round(recommendation.confidence * 100)
                : 0;
            const reasons = recommendation.reason || [];

            banner.className = `ota-banner ${recommendation.action}`;
            banner.innerHTML = `
                <div class="action">OTA Recommendation (Decision Support): ${action}</div>
                <div class="confidence">Confidence: ${confidence}%</div>
                ${reasons.length > 0 ? `
                <div class="section">
                    <b>Reason:</b>
                    <ul>
                        ${reasons.map(r => `<li>${r}</li>`).join('')}
                    </ul>
                </div>
                ` : ''}
            `;
            banner.classList.remove('hidden');
        }

        // Render Anomaly Event (from persisted events only)
        // CRITICAL: This function renders HISTORICAL data only
        // - event.anomalyScore is the score AT THE TIME the event was created
        // - This is NOT the current anomaly score
        // - Current anomaly score is ONLY displayed in Overview/Info tab from devices collection
        function renderAnomalyEvent(event) {
            if (!event || !event.timestamp) {
                return '';
            }

            const timestamp = formatTime(event.timestamp);
            // CRITICAL: This score is HISTORICAL - from when event was created
            const score = typeof event.anomalyScore === 'number' ? event.anomalyScore.toFixed(2) : null;
            const threshold = typeof event.threshold === 'number' ? event.threshold.toFixed(2) : null;

            // Get first explanation if exists
            const exp = event.explanations && event.explanations.length > 0
                ? event.explanations[0]
                : null;

            // OTA Recommendation if exists
            const otaRec = event.otaRecommendation;

            // Build sections conditionally
            let metaSection = '';
            let explanationSection = '';
            let evidenceSection = '';
            let otaSection = '';

            // Meta section (Category, Severity, Risk) - only if explanation exists
            if (exp) {
                const metaItems = [];
                if (exp.category) {
                    metaItems.push(`<div><b>Category:</b> ${exp.category}</div>`);
                }
                if (exp.severity) {
                    metaItems.push(`<div><b>Severity:</b> <span class="severity-${exp.severity}">${exp.severity}</span></div>`);
                }
                if (exp.risk) {
                    metaItems.push(`<div><b>Risk:</b> ${exp.risk}</div>`);
                }
                if (metaItems.length > 0) {
                    metaSection = `<div class="meta">${metaItems.join('')}</div>`;
                }
            }

            // Explanation section - only if interpretation exists
            if (exp && exp.interpretation) {
                explanationSection = `
                    <div class="section">
                        <b>Explanation:</b>
                        <div>${exp.interpretation}</div>
                    </div>
                `;
            }

            // Evidence section - only if evidence exists
            if (exp && exp.evidence && Object.keys(exp.evidence).length > 0) {
                const evidenceItems = Object.entries(exp.evidence)
                    .map(([k, v]) => {
                        let formattedValue = v;
                        if (typeof v === 'number') {
                            if (k.includes('pct') || k.includes('percent')) {
                                formattedValue = `${v.toFixed(1)}`;
                            } else if (k.includes('ms') || k.includes('latency')) {
                                formattedValue = `${v.toFixed(0)}`;
                            } else if (k.includes('mb') || k.includes('storage')) {
                                formattedValue = `${v.toFixed(0)}`;
                            } else if (k.includes('rssi') || k.includes('dbm')) {
                                formattedValue = `${v.toFixed(0)}`;
                            } else {
                                formattedValue = v.toFixed(2);
                            }
                        }
                        return `<li>${k}: ${formattedValue}</li>`;
                    })
                    .join('');

                evidenceSection = `
                    <div class="section">
                        <b>Evidence:</b>
                        <ul>
                            ${evidenceItems}
                        </ul>
                    </div>
                `;
            }

            // OTA Recommendation section - only if exists
            if (otaRec && otaRec.action) {
                const action = otaRec.action.toUpperCase();
                const confidence = typeof otaRec.confidence === 'number'
                    ? Math.round(otaRec.confidence * 100)
                    : 0;
                const reasons = otaRec.reason || [];

                let reasonsHtml = '';
                if (reasons.length > 0) {
                    reasonsHtml = `
                        <ul>
                            ${reasons.map(r => `<li>${r}</li>`).join('')}
                        </ul>
                    `;
                }

                otaSection = `
                    <div class="section">
                        <b>OTA Recommendation (Decision Support):</b>
                        <div>${action}${confidence > 0 ? ` (${confidence}%)` : ''}</div>
                        ${reasonsHtml}
                    </div>
                `;
            }

            // Build headline with score/threshold
            let headline = 'Anomaly detected';
            if (score !== null && threshold !== null) {
                headline = `Anomaly detected (score: ${score} / threshold: ${threshold})`;
            } else if (score !== null) {
                headline = `Anomaly detected (score: ${score})`;
            }

            return `
                <div class="anomaly-event">
                    <div class="timestamp">[${timestamp}]</div>
                    <div class="headline">${headline}</div>
                    ${metaSection}
                    ${explanationSection}
                    ${evidenceSection}
                    ${otaSection}
                </div>
            `;
        }

        // Load anomalies (lazy loading - only when tab is opened)
        // CRITICAL ARCHITECTURE RULE:
        // - This function ONLY renders HISTORY (anomalies collection)
        // - It NEVER updates device header/overview
        // - It NEVER displays current anomaly score
        // - It NEVER derives current state from events
        // - Current state comes ONLY from devices collection via GET /api/devices/:id
        async function loadAnomalies(deviceId) {
            const container = document.getElementById('anomaly-timeline');
            const otaBanner = document.getElementById('ota-banner');

            try {
                // Fetch HISTORY ONLY - no derived state
                const data = await api.devices.anomalies(deviceId);
                const events = Array.isArray(data.data) ? data.data : [];

                if (!events.length) {
                    container.innerHTML = '<div class="loading">No anomaly events recorded.</div>';
                    otaBanner.classList.add('hidden');
                    return;
                }

                // === OTA Banner (only show if current device state is anomalous) ===
                // CRITICAL: Fetch current device state separately for banner visibility ONLY
                // This does NOT update device header - it's only used for banner visibility check
                const deviceData = await api.devices.get(deviceId);
                const device = deviceData.data;

                // OTA banner visibility depends on CURRENT state from devices collection, not history
                // CRITICAL: We use events[0] ONLY for recommendation content, NOT for state
                if (device.isAnomaly === true && events[0]?.otaRecommendation) {
                    renderOTABanner(events[0].otaRecommendation, otaBanner);
                } else {
                    otaBanner.classList.add('hidden');
                }

                // === Render anomaly timeline (ALWAYS visible - it's history) ===
                // CRITICAL: Timeline entries show HISTORICAL scores from events, NOT current state
                // Each event.anomalyScore is from when the event was created, not current score
                container.innerHTML = events.map(renderAnomalyEvent).join('');

            } catch (err) {
                container.innerHTML = '<div class="loading">Failed to load anomaly events.</div>';
                otaBanner.classList.add('hidden');
                console.error('Failed to load anomalies:', err);
            }
        }

        // Alias for backward compatibility
        async function loadAnomaly() {
            await loadAnomalies(deviceId);
        }

        // WebSocket updates
        const socket = realtime.connect();
        if (socket && realtime.isConnected()) {
            realtime.subscribeDevice(deviceId);

            realtime.on('logs', (data) => {
                if ((data.deviceId === deviceId || data.device_id === deviceId) && currentTab === 'logs') {
                    prependLog(data);
                }
            });

            realtime.on('log:new', (data) => {
                if ((data.deviceId === deviceId || data.device_id === deviceId) && currentTab === 'logs') {
                    prependLog(data);
                }
            });

            realtime.on('metrics', (data) => {
                if (data.deviceId === deviceId && currentTab === 'metrics') {
                    // NOTE: For MVP simplicity, metrics are fully reloaded on realtime updates.
                    // This avoids complex state sync issues.
                    // Future improvement: append new points to existing datasets
                    // instead of refetching the entire time range.
                    loadMetrics();
                }
            });

            realtime.on('metric:new', (data) => {
                if (data.deviceId === deviceId && currentTab === 'metrics') {
                    // NOTE: For MVP simplicity, metrics are fully reloaded on realtime updates.
                    // This avoids complex state sync issues.
                    // Future improvement: append new points to existing datasets
                    // instead of refetching the entire time range.
                    loadMetrics();
                }
            });

            realtime.on('ota_progress', (data) => {
                if (data.device_id === deviceId && currentTab === 'ota') {
                    loadOTAHistory();
                }
            });

            realtime.on('anomaly', (data) => {
                if (data.device_id === deviceId && currentTab === 'anomaly') {
                    loadAnomaly();
                }
            });

            realtime.on('device:update', (data) => {
                if (data.deviceId === deviceId) {
                    // NOTE: For MVP simplicity, device info (including anomaly status) is fully reloaded on updates.
                    // This ensures anomaly badge and score stay in sync with backend ML inference.
                    // Future improvement: update only affected fields without full reload.
                    loadDeviceInfo();
                }
            });
        } else if (realtime.isPollingFallback()) {
            // Fallback to polling if WebSocket unavailable
            setInterval(() => {
                if (currentTab === 'metrics') loadMetrics();
                if (currentTab === 'logs') loadLogs();
                if (currentTab === 'ota') loadOTAHistory();
                if (currentTab === 'anomaly') loadAnomaly();
            }, 5000);
        }

        // Initial load
        loadDeviceInfo();
    </script>
</body>
</html>