<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Device Detail - OTA Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>
<body class="bg-white text-gray-900">
    <!-- Sidebar -->
    <aside class="fixed left-0 top-0 h-screen w-60 bg-white border-r border-gray-200 z-50">
        <div class="p-6">
            <h1 class="text-xl font-bold text-gray-900 mb-8">OTA Dashboard</h1>
            <nav class="space-y-2">
                <a href="/" class="block px-4 py-2 rounded-lg text-gray-700 hover:bg-gray-50">Dashboard</a>
                <a href="/devices.html" class="block px-4 py-2 rounded-lg bg-blue-50 text-blue-600 font-semibold">Devices</a>
                <a href="/firmware.html" class="block px-4 py-2 rounded-lg text-gray-700 hover:bg-gray-50">Firmware</a>
                <a href="/model.html" class="block px-4 py-2 rounded-lg text-gray-700 hover:bg-gray-50">Model</a>
                <a href="/logs.html" class="block px-4 py-2 rounded-lg text-gray-700 hover:bg-gray-50">Logs</a>
                <a href="/metrics.html" class="block px-4 py-2 rounded-lg text-gray-700 hover:bg-gray-50">Metrics</a>
                <a href="/anomaly.html" class="block px-4 py-2 rounded-lg text-gray-700 hover:bg-gray-50">Anomaly</a>
            </nav>
        </div>
    </aside>

    <!-- Main Content -->
    <div class="ml-60 p-6">
        <div id="deviceInfo" class="mb-6">
            <div class="flex items-center justify-center p-8">
                <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
            </div>
        </div>

        <div class="border-b border-gray-200 mb-6 overflow-x-auto">
            <nav class="flex space-x-8 min-w-max">
                <button onclick="showTab('info')" id="tab-info" class="tab-button py-4 px-1 border-b-2 border-blue-500 font-medium text-sm text-gray-900 whitespace-nowrap">Info</button>
                <button onclick="showTab('metrics')" id="tab-metrics" class="tab-button py-4 px-1 border-b-2 border-transparent text-gray-600 hover:text-gray-900 text-sm whitespace-nowrap">Metrics</button>
                <button onclick="showTab('logs')" id="tab-logs" class="tab-button py-4 px-1 border-b-2 border-transparent text-gray-600 hover:text-gray-900 text-sm whitespace-nowrap">Logs</button>
                <button onclick="showTab('ota')" id="tab-ota" class="tab-button py-4 px-1 border-b-2 border-transparent text-gray-600 hover:text-gray-900 text-sm whitespace-nowrap">OTA History</button>
                <button onclick="showTab('anomaly')" id="tab-anomaly" class="tab-button py-4 px-1 border-b-2 border-transparent text-gray-600 hover:text-gray-900 text-sm whitespace-nowrap">Anomaly Timeline</button>
            </nav>
        </div>

        <div id="tab-content">
            <div id="content-info" class="tab-content">
                <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
                    <div id="infoContent">Loading...</div>
                </div>
            </div>

            <div id="content-metrics" class="tab-content hidden">
                <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
                    <div id="metricsContent">
                        <div class="flex items-center justify-center p-8">
                            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="content-logs" class="tab-content hidden">
                <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
                    <div id="logsContent">Loading...</div>
                </div>
            </div>

            <div id="content-ota" class="tab-content hidden">
                <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
                    <div id="otaContent">Loading...</div>
                </div>
            </div>

            <div id="content-anomaly" class="tab-content hidden">
                <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
                    <div id="anomalyContent">Loading...</div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { api } from './js/api.js';
        import { realtime } from './js/realtime.js';
        import { charts } from './js/charts.js';
        import { ui } from './js/ui.js';

        const urlParams = new URLSearchParams(window.location.search);
        const deviceId = urlParams.get('device_id');

        if (!deviceId) {
            window.location.href = '/devices.html';
        }

        let currentTab = 'info';
        let metricsCharts = {
            cpu: null,
            temperature: null,
            battery: null,
        };
        let metricsAutoRefreshInterval = null;
        let logsList = [];
        const MAX_LOGS_DISPLAY = 200;

        window.showTab = function(tab) {
            currentTab = tab;
            
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('border-blue-500', 'font-medium', 'text-gray-900');
                btn.classList.add('border-transparent', 'text-gray-600');
            });
            document.getElementById(`tab-${tab}`).classList.add('border-blue-500', 'font-medium', 'text-gray-900');
            document.getElementById(`tab-${tab}`).classList.remove('text-gray-600');

            // Show/hide content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.add('hidden');
            });
            document.getElementById(`content-${tab}`).classList.remove('hidden');

            // Load tab data
            loadTabData(tab);

            // Clear auto-refresh when switching away from metrics tab
            if (tab !== 'metrics' && metricsAutoRefreshInterval) {
                clearInterval(metricsAutoRefreshInterval);
                metricsAutoRefreshInterval = null;
                const checkbox = document.getElementById('metricsAutoRefresh');
                if (checkbox) checkbox.checked = false;
            }
        };

        async function loadDeviceInfo() {
            try {
                const data = await api.devices.get(deviceId);
                const device = data.data;

                document.getElementById('deviceInfo').innerHTML = `
                    <div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6">
                        <h2 class="text-xl font-bold mb-4 text-gray-900">${device.deviceId || device.id}</h2>
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                            <div>
                                <div class="text-sm text-gray-600">Type</div>
                                <div class="font-medium text-gray-900">${device.deviceType || 'N/A'}</div>
                            </div>
                            <div>
                                <div class="text-sm text-gray-600">Status</div>
                                <div><span class="px-2 py-1 rounded-md text-xs font-medium ${ui.getStatusColor(device.status)}">${device.status || 'unknown'}</span></div>
                            </div>
                            <div>
                                <div class="text-sm text-gray-600">Firmware</div>
                                <div class="font-medium text-gray-900">${device.firmwareVersion || 'N/A'}</div>
                            </div>
                            <div>
                                <div class="text-sm text-gray-600">OTA Status</div>
                                <div><span class="px-2 py-1 rounded-md text-xs font-medium ${ui.getOTAStatusColor(device.otaStatus)}">${device.otaStatus || 'N/A'}</span></div>
                            </div>
                            <div>
                                <div class="text-sm text-gray-600">Reported FW</div>
                                <div class="font-medium text-gray-900">${device.reportedFirmwareVersion || 'N/A'}</div>
                            </div>
                            <div>
                                <div class="text-sm text-gray-600">Anomaly Status</div>
                                <div>
                                    ${(() => {
                                        // NOTE: anomalyScore and isAnomaly come from backend ML inference.
                                        // UI does not compute or decide anomaly state.
                                        // Future work: anomaly history & explainability.
                                        if (device.isAnomaly === true) {
                                            return `<span class="px-2 py-1 rounded-md text-xs font-medium bg-red-100 text-red-800">Anomaly</span>`;
                                        } else if (device.isAnomaly === false || (device.anomalyScore !== null && device.anomalyScore !== undefined)) {
                                            return `<span class="px-2 py-1 rounded-md text-xs font-medium bg-green-100 text-green-800">Normal</span>`;
                                        } else {
                                            return '<span class="px-2 py-1 rounded-md text-xs font-medium bg-gray-100 text-gray-800">N/A</span>';
                                        }
                                    })()}
                                </div>
                            </div>
                            <div>
                                <div class="text-sm text-gray-600">Last Seen</div>
                                <div class="font-medium text-gray-900">${ui.formatDate(device.lastSeenAt || device.lastCheckin || device.lastSeen)}</div>
                            </div>
                        </div>
                    </div>
                `;

                if (currentTab === 'info') {
                    loadInfoTab(device);
                }
            } catch (error) {
                document.getElementById('deviceInfo').innerHTML = 
                    `<div class="p-4 bg-red-50 border border-red-200 rounded text-red-700">Error: ${error.message}</div>`;
            }
        }

        async function loadInfoTab(device) {
            document.getElementById('infoContent').innerHTML = `
                <div class="space-y-4">
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <div class="text-sm text-gray-600">Device ID</div>
                            <div class="font-medium text-gray-900">${device.deviceId || device.id}</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-600">Device Type</div>
                            <div class="font-medium text-gray-900">${device.deviceType || 'N/A'}</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-600">Firmware Version</div>
                            <div class="font-medium text-gray-900">${device.firmwareVersion || 'N/A'}</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-600">Reported FW Version</div>
                            <div class="font-medium text-gray-900">${device.reportedFirmwareVersion || 'N/A'}</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-600">Status</div>
                            <div><span class="px-2 py-1 rounded-md text-xs font-medium ${ui.getStatusColor(device.status)}">${device.status || 'unknown'}</span></div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-600">OTA Status</div>
                            <div><span class="px-2 py-1 rounded-md text-xs font-medium ${ui.getOTAStatusColor(device.otaStatus)}">${device.otaStatus || 'N/A'}</span></div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-600">Last Seen</div>
                            <div class="font-medium text-gray-900">${ui.formatDate(device.lastSeenAt || device.lastCheckin || device.lastSeen)}</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-600">Log Count</div>
                            <div class="font-medium text-gray-900">${device.logCount || 0}</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-600">Metric Count</div>
                            <div class="font-medium text-gray-900">${device.metricCount || 0}</div>
                        </div>
                    </div>
                    <div class="mt-6 pt-6 border-t border-gray-200">
                        <h3 class="text-sm font-semibold text-gray-900 mb-3">Anomaly Status</h3>
                        <div class="space-y-2">
                            <div class="flex items-center space-x-3">
                                ${(() => {
                                    // NOTE: anomalyScore and isAnomaly come from backend ML inference.
                                    // UI does not compute or decide anomaly state.
                                    // Future work: anomaly history & explainability.
                                    if (device.isAnomaly === true) {
                                        return `<span class="px-3 py-1 rounded-md text-sm font-medium bg-red-100 text-red-800">Anomaly</span>`;
                                    } else if (device.isAnomaly === false || (device.anomalyScore !== null && device.anomalyScore !== undefined)) {
                                        return `<span class="px-3 py-1 rounded-md text-sm font-medium bg-green-100 text-green-800">Normal</span>`;
                                    } else {
                                        return '<span class="px-3 py-1 rounded-md text-sm font-medium bg-gray-100 text-gray-800">N/A</span>';
                                    }
                                })()}
                                ${device.anomalyScore !== null && device.anomalyScore !== undefined && typeof device.anomalyScore === 'number'
                                    ? `<span class="text-sm text-gray-600">Score: ${device.anomalyScore.toFixed(3)}</span>`
                                    : ''}
                            </div>
                            <p class="text-xs text-gray-500 mt-2">
                                Anomaly score is generated by the inference model based on recent metrics.
                            </p>
                        </div>
                    </div>
                </div>
            `;
        }

        async function loadTabData(tab) {
            if (tab === 'info') {
                const data = await api.devices.get(deviceId);
                loadInfoTab(data.data);
            } else if (tab === 'metrics') {
                await loadMetrics();
            } else if (tab === 'logs') {
                await loadLogs();
            } else if (tab === 'ota') {
                await loadOTAHistory();
            } else if (tab === 'anomaly') {
                await loadAnomaly();
            }
        }

        async function loadMetrics() {
            const metricsContent = document.getElementById('metricsContent');
            
            // Show loading state
            metricsContent.innerHTML = `
                <div class="flex items-center justify-center p-8">
                    <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
                </div>
            `;

            try {
                const data = await api.metrics.list({ deviceId, limit: 200 });
                
                // Defensive: NEVER assume data exists, NEVER call .map() on undefined
                // Rules: Empty data is VALID, UI must stay on Metrics tab, no navigation reset
                const metrics = data?.data ?? [];

                if (!Array.isArray(metrics) || metrics.length === 0) {
                    metricsContent.innerHTML = 
                        '<div class="p-8 text-center text-gray-500">No metrics data available</div>';
                    return;
                }

                // NOTE: Metric keys are fixed for current device models.
                // Backend supports arbitrary metrics fields.
                // UI is intentionally constrained for clarity and stability.
                // Dynamic metric rendering can be added in future iterations.

                // Transform API response to chart-friendly format
                const chartData = {
                    cpu: [],
                    temperature: [],
                    battery: [],
                };

                // Defensive: Ensure metrics is array before forEach
                (Array.isArray(metrics) ? metrics : []).forEach(metric => {
                    if (!metric || !metric.timestamp) return; // Skip invalid metrics
                    const timestamp = new Date(metric.timestamp);
                    const metricValues = metric.metrics || {};

                    // Map metric keys to chart datasets (fixed keys: cpu_usage, temperature, battery_level)
                    if (metricValues.cpu_usage !== undefined) {
                        chartData.cpu.push({ x: timestamp, y: metricValues.cpu_usage });
                    }
                    if (metricValues.temperature !== undefined) {
                        chartData.temperature.push({ x: timestamp, y: metricValues.temperature });
                    }
                    if (metricValues.battery_level !== undefined) {
                        chartData.battery.push({ x: timestamp, y: metricValues.battery_level });
                    }
                });

                // Sort all datasets by timestamp (ascending)
                Object.keys(chartData).forEach(key => {
                    chartData[key].sort((a, b) => a.x - b.x);
                });

                // Get last values for display
                const lastCpu = chartData.cpu.at(-1)?.y;
                const lastTemp = chartData.temperature.at(-1)?.y;
                const lastBattery = chartData.battery.at(-1)?.y;

                // Render charts HTML with auto-refresh toggle
                metricsContent.innerHTML = `
                    <div class="space-y-6">
                        <div class="flex items-center justify-between mb-4">
                            <div></div>
                            <label class="flex items-center space-x-2 cursor-pointer">
                                <input type="checkbox" id="metricsAutoRefresh" class="w-4 h-4 text-blue-600 rounded focus:ring-blue-500">
                                <span class="text-sm text-gray-700">Auto refresh (30s)</span>
                            </label>
                        </div>
                        <div>
                            <h3 class="text-lg font-semibold text-gray-900 mb-2">
                                CPU Usage${lastCpu !== undefined ? ` (last: ${(lastCpu * 100).toFixed(1)}%)` : ''}
                            </h3>
                            <div class="h-64">
                                <canvas id="cpuChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <h3 class="text-lg font-semibold text-gray-900 mb-2">
                                Temperature${lastTemp !== undefined ? ` (last: ${lastTemp.toFixed(1)}°C)` : ''}
                            </h3>
                            <div class="h-64">
                                <canvas id="temperatureChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <h3 class="text-lg font-semibold text-gray-900 mb-2">
                                Battery Level${lastBattery !== undefined ? ` (last: ${(lastBattery * 100).toFixed(1)}%)` : ''}
                            </h3>
                            <div class="h-64">
                                <canvas id="batteryChart"></canvas>
                            </div>
                        </div>
                    </div>
                `;

                // Setup auto-refresh toggle
                const autoRefreshCheckbox = document.getElementById('metricsAutoRefresh');
                autoRefreshCheckbox.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        metricsAutoRefreshInterval = setInterval(() => {
                            if (currentTab === 'metrics') {
                                loadMetrics();
                            }
                        }, 30000);
                    } else {
                        if (metricsAutoRefreshInterval) {
                            clearInterval(metricsAutoRefreshInterval);
                            metricsAutoRefreshInterval = null;
                        }
                    }
                });

                // Destroy existing charts
                if (metricsCharts.cpu) charts.destroy('cpuChart');
                if (metricsCharts.temperature) charts.destroy('temperatureChart');
                if (metricsCharts.battery) charts.destroy('batteryChart');

                // Create CPU Usage chart
                if (chartData.cpu.length > 0) {
                    metricsCharts.cpu = charts.create('cpuChart', {
                        type: 'line',
                        data: {
                            datasets: [{
                                label: 'CPU Usage',
                                data: chartData.cpu,
                                borderColor: 'rgb(59, 130, 246)',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                tension: 0.1,
                                borderWidth: 2,
                                fill: true,
                            }],
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                mode: 'index',
                                intersect: false,
                            },
                            plugins: {
                                tooltip: {
                                    enabled: true,
                                    callbacks: {
                                        title: (items) => {
                                            return new Date(items[0].parsed.x).toLocaleString();
                                        },
                                        label: (context) => {
                                            return `CPU Usage: ${(context.parsed.y * 100).toFixed(1)}%`;
                                        },
                                    },
                                },
                                legend: {
                                    display: false,
                                },
                            },
                            scales: {
                                x: {
                                    type: 'time',
                                    time: {
                                        tooltipFormat: 'yyyy-MM-dd HH:mm:ss',
                                        displayFormats: {
                                            second: 'HH:mm:ss',
                                            minute: 'HH:mm',
                                            hour: 'HH:mm',
                                        },
                                    },
                                    ticks: {
                                        color: '#6b7280',
                                    },
                                    grid: {
                                        color: '#e5e7eb',
                                    },
                                },
                                y: {
                                    ticks: {
                                        color: '#6b7280',
                                        callback: function(value) {
                                            return (value * 100).toFixed(0) + '%';
                                        },
                                    },
                                    grid: { color: '#e5e7eb' },
                                    min: 0,
                                    max: 1,
                                },
                            },
                        },
                    });
                } else {
                    document.getElementById('cpuChart').parentElement.innerHTML = 
                        '<div class="p-4 text-center text-gray-500">No CPU usage data available</div>';
                }

                // Create Temperature chart
                if (chartData.temperature.length > 0) {
                    metricsCharts.temperature = charts.create('temperatureChart', {
                        type: 'line',
                        data: {
                            datasets: [{
                                label: 'Temperature',
                                data: chartData.temperature,
                                borderColor: 'rgb(239, 68, 68)',
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                tension: 0.1,
                                borderWidth: 2,
                                fill: true,
                            }],
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                mode: 'index',
                                intersect: false,
                            },
                            plugins: {
                                tooltip: {
                                    enabled: true,
                                    callbacks: {
                                        title: (items) => {
                                            return new Date(items[0].parsed.x).toLocaleString();
                                        },
                                        label: (context) => {
                                            return `Temperature: ${context.parsed.y.toFixed(1)}°C`;
                                        },
                                    },
                                },
                                legend: {
                                    display: false,
                                },
                            },
                            scales: {
                                x: {
                                    type: 'time',
                                    time: {
                                        tooltipFormat: 'yyyy-MM-dd HH:mm:ss',
                                        displayFormats: {
                                            second: 'HH:mm:ss',
                                            minute: 'HH:mm',
                                            hour: 'HH:mm',
                                        },
                                    },
                                    ticks: {
                                        color: '#6b7280',
                                    },
                                    grid: {
                                        color: '#e5e7eb',
                                    },
                                },
                                y: {
                                    ticks: {
                                        color: '#6b7280',
                                        callback: function(value) {
                                            return value.toFixed(1) + '°C';
                                        },
                                    },
                                    grid: { color: '#e5e7eb' },
                                },
                            },
                        },
                    });
                } else {
                    document.getElementById('temperatureChart').parentElement.innerHTML = 
                        '<div class="p-4 text-center text-gray-500">No temperature data available</div>';
                }

                // Create Battery Level chart
                if (chartData.battery.length > 0) {
                    metricsCharts.battery = charts.create('batteryChart', {
                        type: 'line',
                        data: {
                            datasets: [{
                                label: 'Battery Level',
                                data: chartData.battery,
                                borderColor: 'rgb(34, 197, 94)',
                                backgroundColor: 'rgba(34, 197, 94, 0.1)',
                                tension: 0.1,
                                borderWidth: 2,
                                fill: true,
                            }],
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                mode: 'index',
                                intersect: false,
                            },
                            plugins: {
                                tooltip: {
                                    enabled: true,
                                    callbacks: {
                                        title: (items) => {
                                            return new Date(items[0].parsed.x).toLocaleString();
                                        },
                                        label: (context) => {
                                            return `Battery Level: ${(context.parsed.y * 100).toFixed(1)}%`;
                                        },
                                    },
                                },
                                legend: {
                                    display: false,
                                },
                            },
                            scales: {
                                x: {
                                    type: 'time',
                                    time: {
                                        tooltipFormat: 'yyyy-MM-dd HH:mm:ss',
                                        displayFormats: {
                                            second: 'HH:mm:ss',
                                            minute: 'HH:mm',
                                            hour: 'HH:mm',
                                        },
                                    },
                                    ticks: {
                                        color: '#6b7280',
                                    },
                                    grid: {
                                        color: '#e5e7eb',
                                    },
                                },
                                y: {
                                    ticks: {
                                        color: '#6b7280',
                                        callback: function(value) {
                                            return (value * 100).toFixed(0) + '%';
                                        },
                                    },
                                    grid: { color: '#e5e7eb' },
                                    min: 0,
                                    max: 1,
                                },
                            },
                        },
                    });
                } else {
                    document.getElementById('batteryChart').parentElement.innerHTML = 
                        '<div class="p-4 text-center text-gray-500">No battery level data available</div>';
                }
            } catch (error) {
                metricsContent.innerHTML = 
                    `<div class="p-4 bg-red-50 border border-red-200 rounded text-red-700">Error: ${error.message}</div>`;
            }
        }

        function renderLogs(logs) {
            const logsContent = document.getElementById('logsContent');
            
            // Defensive: Empty data is VALID, show empty state, stay on tab
            if (!Array.isArray(logs) || logs.length === 0) {
                logsContent.innerHTML = `
                    <div class="space-y-4">
                        <div class="p-8 text-center text-gray-500">No logs available for this device</div>
                        <div class="text-center">
                            <a href="/logs.html?deviceId=${encodeURIComponent(deviceId)}" 
                               class="text-blue-600 hover:text-blue-700 underline">
                                View all logs in Logs tab →
                            </a>
                        </div>
                    </div>
                `;
                return;
            }

            // Backend already sorts by @timestamp DESC, so no frontend sorting needed
            // Logs are already normalized with timestamp field

            logsContent.innerHTML = `
                <div class="space-y-4">
                    <div class="flex justify-between items-center">
                        <h3 class="text-lg font-semibold text-gray-900">Recent Logs (Latest 10)</h3>
                        <a href="/logs.html?deviceId=${encodeURIComponent(deviceId)}" 
                           class="text-sm text-blue-600 hover:text-blue-700 underline">
                            View all logs →
                        </a>
                    </div>
                    <div class="space-y-2">
                        ${logs.map(log => {
                            const timestamp = log.timestamp ? ui.formatDate(log.timestamp) : 'unknown time';
                            const levelColor = log.level === 'ERROR' 
                                ? 'bg-red-100 text-red-800' 
                                : log.level === 'WARN' 
                                ? 'bg-yellow-100 text-yellow-800' 
                                : 'bg-blue-100 text-blue-800';

                            return `
                                <div class="p-3 bg-gray-50 rounded text-sm border border-gray-200">
                                    <div class="flex justify-between">
                                        <span class="text-gray-600">${timestamp}</span>
                                        <span class="px-2 py-1 rounded text-xs ${levelColor}">${log.level.toUpperCase()}</span>
                                    </div>
                                    <div class="mt-1 text-gray-900">${log.message}</div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            `;
        }

        async function loadLogs() {
            const logsContent = document.getElementById('logsContent');
            
            // Show loading state
            logsContent.innerHTML = `
                <div class="flex items-center justify-center p-8">
                    <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
                </div>
            `;

            try {
                // Call API /api/logs with deviceId and limit 10 (latest logs only)
                const response = await api.logs.list({ deviceId, limit: 10 });
                
                // Defensive: read from data.data (backend returns { success: true, data: [...] })
                if (!response || !response.data) {
                    logsContent.innerHTML = 
                        '<div class="p-8 text-center text-gray-500">No logs available for this device</div>';
                    logsList = [];
                    return;
                }

                const rawLogs = Array.isArray(response.data) ? response.data : [];
                
                // Normalize logs: map @timestamp to timestamp for clean UI rendering
                const normalizedLogs = rawLogs.map(log => ({
                    id: log.id,
                    timestamp: log['@timestamp'] || log.timestamp,
                    deviceId: log.deviceId || log.device_id || 'N/A',
                    level: log.level || 'info',
                    message: log.message || '(empty message)',
                }));
                
                logsList = normalizedLogs;
                renderLogs(logsList);
            } catch (error) {
                // Show error state
                logsContent.innerHTML = 
                    `<div class="p-4 bg-red-50 border border-red-200 rounded text-red-700">Error: ${error.message || 'Failed to load logs'}</div>`;
                logsList = [];
            }
        }

        function prependLog(newLog) {
            // NOTE: For MVP, realtime logs are prepended locally.
            // Future improvement: virtualized list or server-side pagination.
            
            if (!newLog) return;

            // Normalize log: map @timestamp to timestamp
            const log = {
                id: newLog.id || `realtime-${Date.now()}`,
                deviceId: newLog.deviceId || newLog.device_id || 'unknown',
                level: newLog.level || 'info',
                message: newLog.message || '(empty message)',
                timestamp: newLog['@timestamp'] || newLog.timestamp || new Date().toISOString(),
            };

            // Prepend to list (newest first)
            logsList.unshift(log);

            // Cap list length to 10 (latest only)
            if (logsList.length > 10) {
                logsList = logsList.slice(0, 10);
            }

            // Re-render if on logs tab
            if (currentTab === 'logs') {
                renderLogs(logsList);
            }
        }

        async function loadOTAHistory() {
            try {
                const data = await api.ota.history(deviceId);
                const history = data.data || [];

                document.getElementById('otaContent').innerHTML = `
                    <div class="space-y-3">
                        ${history.map(item => `
                            <div class="p-4 bg-gray-50 rounded border border-gray-200">
                                <div class="flex justify-between items-center">
                                    <div>
                                        <div class="font-medium text-gray-900">${item.firmwareVersion}</div>
                                        <div class="text-sm text-gray-600">${ui.formatDate(item.deployedAt)}</div>
                                    </div>
                                    <span class="px-2 py-1 rounded-md text-xs font-medium ${ui.getOTAStatusColor(item.status)}">${item.status}</span>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            } catch (error) {
                document.getElementById('otaContent').innerHTML = 
                    `<div class="p-4 bg-red-50 border border-red-200 rounded text-red-700">Error: ${error.message}</div>`;
            }
        }

        async function loadAnomaly() {
            try {
                const data = await api.anomaly.get(deviceId);
                const anomaly = data.data || {};
                
                // Defensive: safely extract score and threshold
                // CRITICAL: Use anomalyScore field, never score field
                const score = anomaly.anomalyScore ?? null; // Only use anomalyScore, ignore score
                const threshold = typeof anomaly.threshold === 'number' ? anomaly.threshold : 0.5;
                const backendIsAnomaly = anomaly.isAnomaly; // Backend is source of truth
                
                // Status logic: MUST trust backend isAnomaly flag
                // Only recompute if backend flag is missing
                let status = 'Unknown';
                let isAnomaly = null;
                
                if (typeof backendIsAnomaly === 'boolean') {
                    // Backend is source of truth - use its flag directly
                    isAnomaly = backendIsAnomaly;
                    status = backendIsAnomaly ? 'Anomaly' : 'Normal';
                } else if (typeof score === 'number' && typeof threshold === 'number') {
                    // Fallback: only compute if backend flag is missing
                    isAnomaly = score >= threshold;
                    status = isAnomaly ? 'Anomaly' : 'Normal';
                }

                // Get historical anomaly data from logs/metrics for timeline
                let timelineData = [];
                try {
                    const logsData = await api.logs.list({ deviceId, limit: 100 });
                    const rawLogs = Array.isArray(logsData.data) ? logsData.data : [];
                    
                    // Normalize logs: map @timestamp to timestamp
                    const normalizedLogs = rawLogs.map(log => ({
                        id: log.id,
                        timestamp: log['@timestamp'] || log.timestamp,
                        deviceId: log.deviceId || log.device_id || 'N/A',
                        level: log.level || 'info',
                        message: log.message || '(empty message)',
                    }));
                    
                    // Extract anomaly-related logs
                    timelineData = normalizedLogs
                        .filter(log => log.level === 'ERROR' || log.message?.toLowerCase().includes('anomaly'))
                        .slice(0, 20)
                        .map(log => ({
                            time: log.timestamp,
                            type: log.level,
                            message: log.message || 'N/A'
                        }));
                } catch (err) {
                    console.warn('Could not load timeline data:', err);
                }

                // Safe numeric rendering - NEVER call toFixed on null/undefined
                const scoreText = typeof score === 'number' ? score.toFixed(4) : 'N/A';
                const thresholdText = typeof threshold === 'number' ? threshold.toFixed(4) : 'N/A';
                
                // Status color based on computed status
                const statusColor = status === 'Anomaly' ? 'text-red-800' : 
                                   status === 'Normal' ? 'text-green-800' : 
                                   'text-gray-800';
                const scoreColor = status === 'Anomaly' ? 'text-red-600' : 
                                  status === 'Normal' ? 'text-green-600' : 
                                  'text-gray-500';

                document.getElementById('anomalyContent').innerHTML = `
                    <div class="space-y-4">
                        <div class="grid grid-cols-2 gap-4">
                            <div class="p-4 bg-gray-50 rounded border border-gray-200">
                                <div class="text-sm text-gray-600">Current Score</div>
                                <div class="text-2xl font-bold ${scoreColor}">${scoreText}</div>
                            </div>
                            <div class="p-4 bg-gray-50 rounded border border-gray-200">
                                <div class="text-sm text-gray-600">Threshold</div>
                                <div class="text-2xl font-bold text-gray-900">${thresholdText}</div>
                            </div>
                        </div>
                        <div class="p-4 bg-gray-50 rounded border border-gray-200">
                            <div class="text-sm text-gray-600 mb-2">Status</div>
                            <div class="text-lg font-semibold ${statusColor}">
                                ${status === 'Anomaly' ? 'Anomaly Detected' : 
                                  status === 'Normal' ? 'Normal' : 
                                  'Unknown'}
                            </div>
                        </div>
                        <div class="p-4 bg-gray-50 rounded border border-gray-200">
                            <div class="text-sm text-gray-600 mb-2">Explanation</div>
                            <div class="text-gray-900">${anomaly.explanation || anomaly.message || 'No explanation available'}</div>
                        </div>
                        <div class="p-4 bg-white rounded border border-gray-200">
                            <h4 class="text-sm font-semibold text-gray-900 mb-3">Anomaly Timeline</h4>
                            <div class="space-y-2 max-h-96 overflow-y-auto">
                                ${timelineData.length > 0 
                                    ? timelineData.map(item => `
                                        <div class="p-3 bg-gray-50 rounded text-sm border border-gray-200">
                                            <div class="flex justify-between items-start mb-1">
                                                <span class="text-gray-600">${ui.formatDate(item.time)}</span>
                                                <span class="px-2 py-1 rounded text-xs ${item.type === 'ERROR' ? 'bg-red-100 text-red-800' : 'bg-yellow-100 text-yellow-800'}">${item.type}</span>
                                            </div>
                                            <div class="text-gray-900">${item.message}</div>
                                        </div>
                                    `).join('')
                                    : '<div class="text-gray-500 text-sm text-center py-4">No anomaly events in timeline</div>'}
                            </div>
                        </div>
                    </div>
                `;
            } catch (error) {
                document.getElementById('anomalyContent').innerHTML = 
                    `<div class="p-4 bg-red-50 border border-red-200 rounded text-red-700">Error: ${error.message}</div>`;
            }
        }

        // WebSocket updates
        const socket = realtime.connect();
        if (socket && realtime.isConnected()) {
            realtime.subscribeDevice(deviceId);
            
            realtime.on('logs', (data) => {
                if ((data.deviceId === deviceId || data.device_id === deviceId) && currentTab === 'logs') {
                    prependLog(data);
                }
            });

            realtime.on('log:new', (data) => {
                if ((data.deviceId === deviceId || data.device_id === deviceId) && currentTab === 'logs') {
                    prependLog(data);
                }
            });

            realtime.on('metrics', (data) => {
                if (data.deviceId === deviceId && currentTab === 'metrics') {
                    // NOTE: For MVP simplicity, metrics are fully reloaded on realtime updates.
                    // This avoids complex state sync issues.
                    // Future improvement: append new points to existing datasets
                    // instead of refetching the entire time range.
                    loadMetrics();
                }
            });

            realtime.on('metric:new', (data) => {
                if (data.deviceId === deviceId && currentTab === 'metrics') {
                    // NOTE: For MVP simplicity, metrics are fully reloaded on realtime updates.
                    // This avoids complex state sync issues.
                    // Future improvement: append new points to existing datasets
                    // instead of refetching the entire time range.
                    loadMetrics();
                }
            });

            realtime.on('ota_progress', (data) => {
                if (data.device_id === deviceId && currentTab === 'ota') {
                    loadOTAHistory();
                }
            });

            realtime.on('anomaly', (data) => {
                if (data.device_id === deviceId && currentTab === 'anomaly') {
                    loadAnomaly();
                }
            });

            realtime.on('device:update', (data) => {
                if (data.deviceId === deviceId) {
                    // NOTE: For MVP simplicity, device info (including anomaly status) is fully reloaded on updates.
                    // This ensures anomaly badge and score stay in sync with backend ML inference.
                    // Future improvement: update only affected fields without full reload.
                    loadDeviceInfo();
                }
            });
        } else if (realtime.isPollingFallback()) {
            // Fallback to polling if WebSocket unavailable
            setInterval(() => {
                if (currentTab === 'metrics') loadMetrics();
                if (currentTab === 'logs') loadLogs();
                if (currentTab === 'ota') loadOTAHistory();
                if (currentTab === 'anomaly') loadAnomaly();
            }, 5000);
        }

        // Initial load
        loadDeviceInfo();
    </script>
</body>
</html>
